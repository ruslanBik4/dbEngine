{% package _go %}
{% import (
	"fmt"
	"go/types"

	"github.com/iancoleman/strcase"
	"github.com/ruslanBik4/dbEngine/dbEngine"
    "github.com/ruslanBik4/dbEngine/dbEngine/psql"
	"github.com/ruslanBik4/dbEngine/typesExt"
)
%}


{% func (c *Creator) CreateDatabase(listRoutines []string) %}
// Code generated by dbEngine-gen-go. DO NOT EDIT!
// versions:
// 	dbEngine v1.1.6
// source: %s %s

package db

import (
	"fmt"
	"time"
	"strings"
	{%- for _, lib := range c.packages -%}"{%s lib %}"
    {%- endfor -%}

	"github.com/jackc/pgconn"

	"github.com/ruslanBik4/logs"
	"github.com/ruslanBik4/dbEngine/dbEngine"
    "github.com/ruslanBik4/dbEngine/dbEngine/psql"

	"golang.org/x/net/context"
	"github.com/pkg/errors"
)
{%- for name, typ := range c.db.Types -%}{%= c.CreateTypeInterface(typ, strcase.ToCamel(name), name, c.Types[name]) %}{%- endfor -%}

// Database is root interface for operation for %s.%s
type Database struct {
	*dbEngine.DB
	CreateAt time.Time
}
// NewDatabase create new Database with minimal necessary handlers
func NewDatabase(ctx context.Context, noticeHandler pgconn.NoticeHandler, channelHandler pgconn.NotificationHandler, channels ...string) (*Database, error) {
	if noticeHandler == nil {
		noticeHandler = printNotice
	}
	conn := psql.NewConn(nil, nil, noticeHandler, channels...)
	if channelHandler != nil {
		conn.ChannelHandler = channelHandler
	}

	DB, err := dbEngine.NewDB(ctx, conn)
	if err != nil {
		logs.ErrorLog(err, "")
		return nil, err
	}

	return &Database{DB, time.Now()}, nil
}
// PsqlConn return connection as *psql.Conn
// need for some low-level operation,
// invoke Conn.Select...(custom sql),
//        New{table_name}FromConn, etc.
func (d *Database) PsqlConn() *psql.Conn {
	return (d.Conn).(*psql.Conn)
}
{%- for name := range c.db.Tables -%}{%= c.CreateTableConstructor(strcase.ToCamel(name), name) %}{%- endfor -%}
{%- for _, name := range listRoutines -%}{%= c.CreateRoutinesInvoker(c.db.Routines[name].(*psql.Routine), name) %}{%- endfor -%}
// printNotice logging some psql messages (invoked command 'RAISE ...')
func printNotice(c *pgconn.PgConn, n *pgconn.Notice) {

	switch {
    case n.Code == "42P07" || strings.Contains(n.Message, "skipping") :
		logs.DebugLog("skip operation: %%s", n.Message)

	case n.Severity == "INFO" :
		logs.StatusLog(n.Message)

	case n.Code > "00000" :
		err := (*pgconn.PgError)(n)
		logs.CustomLog(logs.CRITICAL, "DB_EXEC",  err.File, int(err.Line),
			fmt.Sprintf("%v, hint: %s, where: %s, %s %s", err, n.Hint, n.Where,  err.SQLState(), err.Routine), logs.FgErr)

	case strings.HasPrefix(n.Message, "[[ERROR]]") :
		logs.ErrorLog(errors.New(strings.TrimPrefix(n.Message, "[[ERROR]]") + n.Severity))

	default: // DEBUG
		logs.DebugLog("%+v %s (PID:%d)", n.Severity, n.Message, c.PID())
	}
}
{% endfunc %}

{%- func (c *Creator) CreateTypeInterface(t dbEngine.Types, typeName, name, typeCol string) -%}
{%- if len(t.Enumerates) > 0 -%}
{%- else -%}
// {%s typeName %} create new instance of type {%s name %}
type {%s typeName %} struct {
{%- for _, tAttr := range t.Attr -%}
	{%s= fmt.Sprintf("%-21s\t%-13s\t",  strcase.ToCamel(tAttr.Name), tAttr.Type) %} `json:"{%s tAttr.Name %}"`
{%- endfor -%}
}

func (dst *{%s typeName %}) DecodeText(ci *pgtype.ConnInfo, src []byte) error {
	if len(src) == 0 {
		*dst = {%s typeName %}{}
		return nil
	}
	srcPart := bytes.Split(src[1:len(src)-1], []byte(","))
    *dst = {%s typeName %}{
	{%- for i, tAttr := range t.Attr -%}
		{%s= c.GetFuncForDecode(tAttr.Name, tAttr.Type, i) %},
        {%- code i++ -%}
	{%- endfor -%}
	}

	return nil
}
{%- endif -%}
{%- endfunc -%}

{%- func (c *Creator) CreateRoutinesInvoker(r *psql.Routine, name string) -%}
{%- code
	camelName := strcase.ToCamel(name)
	args := make([]any, len(r.Params()))
	sql, _, _ := r.BuildSql(dbEngine.ArgsForSelect(args...))
	typeReturn:= ""
-%}
{%- if r.Type == psql.ROUTINE_TYPE_PROC %}
// {%s camelName %} call procedure '{%s name %}'
// DB comment: '{%s r.Comment %}'
func (d *Database) {%s camelName %}(ctx context.Context,
				{%= c.paramsTitle(r)%}
) error {
	return d.Conn.ExecDDL(ctx,
				`{%s sql %}`,
				{%= c.paramsArgs(r) %}
			)
}
{%- else %}
{%- switch len(r.Columns()) -%}
{% case 0 %}
	{%- code
		toType := psql.UdtNameToType(r.UdtName)
	switch toType {
	case types.Invalid:
		typeReturn = c.chkDefineType(r.UdtName)
		if typeReturn == "" {
			typeReturn = "*" + strcase.ToCamel(r.UdtName)
		}

	case types.UntypedFloat:
		typeReturn = "float64"
	default:
		typeReturn = typesExt.Basic(toType).String()
	}
	-%}
{% case 1 %}
	{%- code
		param := r.Columns()[0]
		typeReturn, _ = c.chkTypes(param, strcase.ToCamel(param.Name()))
	-%}
{%- default -%}
// {%s camelName %}RowScanner run query with select
type {%s camelName %}RowScanner struct {
	{%- for _, param := range r.Columns() -%}
		{%- code
			s := strcase.ToCamel(param.Name())
			typeCol, _ := c.chkTypes(param, s)
		-%}
	{%s s %} {%s typeCol %}
	{%- endfor -%}
}
// GetFields implement dbEngine.RowScanner interface
func (r *{%s camelName %}RowScanner) GetFields(columns []dbEngine.Column) []any {
	v := make([]any, len(columns))
	for i, col := range columns {
		switch col.Name() {
		{%- for _, param := range r.Columns() -%}
		case "{%s param.Name() %}":
			v[i] =  &r.{%s= strcase.ToCamel(param.Name()) %}
		{%- endfor -%}
		}
	}

	return v
}
{%- endswitch -%}
// {%s camelName %} run query with select DB function '{%s name %}'
// DB comment: '{%s r.Comment %}'
// ATTENTION! It returns only 1 row
func (d *Database) {%s camelName %}(ctx context.Context,
				{%= c.paramsTitle(r) %}
) (res {% if len(r.Columns()) > 1 -%}*{%s camelName %}RowScanner{%- else -%}{%s typeReturn %}{%- endif -%}, err error) {
	err = d.Conn.SelectOneAndScan(ctx,
				&res,
				`{%s sql %}
				FETCH FIRST 1 ROW ONLY`,
				{%= c.paramsArgs(r) %}
			)

	return
}
{%- if r.ReturnType() == "record" -%}
// {%s camelName %}Each run query with select DB function '{%s name %}'
// DB comment: '{%s r.Comment %}'
// each will get every row from {%s camelName %}sRowScanner
func (d *Database) {%s camelName %}Each(ctx context.Context,
	each func(record *{%s camelName %}RowScanner) error,
	{%= c.paramsTitle(r) %}
) error {
	res := &{%s camelName %}RowScanner{}
	err := d.Conn.SelectAndScanEach(ctx,
				func () error {
					if each != nil {
						return each(res)
					}
					return nil
				},
				res,
				`{%s sql %}`,
				{%= c.paramsArgs(r) %}
		)
	return err
}
{%- endif %}
{%- endif %}
{% endfunc %}
{%- func (c *Creator) paramsTitle(r *psql.Routine) -%}
	{%- for _, param := range r.Params() -%}
	{%- code
		s := strcase.ToLowerCamel(param.Name())
		typeCol, _ := c.chkTypes(param, s)
	-%}
	{%s s %} {%s typeCol %},
	{%- endfor -%}
{%- endfunc -%}
{%- func (c *Creator) paramsArgs(r *psql.Routine) -%}
	{%- for _, param := range r.Params() -%}
	{%s strcase.ToLowerCamel(param.Name()) %},
	{%- endfor -%}
{%- endfunc -%}
{%- func (c *Creator) CreateTableConstructor(cName, name string) -%}
// New{%s cName %} create new instance of table {%s cName %}
func (d *Database) New{%s cName %}(ctx context.Context) (*{%s cName %}, error) {
	const name = "{%s name %}"
	table, ok := d.Tables[name]
    if !ok {
		var err error
		table, err = New{%s cName %}FromConn(ctx, d.PsqlConn())
		if err != nil {
			return nil, err
		}
		d.Tables[name] = table
    }

    return &{%s cName %}{
		Table: table.(*psql.Table),
    }, nil
}
{% endfunc %}